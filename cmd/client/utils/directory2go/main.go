// Copyright Â© 2017 ZhongAn Technology
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

import (
	"bytes"
	"encoding/base64"
	"flag"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"text/template"
)

var src = flag.String("src", "", "src directory name")
var dst = flag.String("dst", "", "out put directory name")
var pkg = flag.String("pkg", "", "generated package name")

// dgo, directory to go file, generate go file from directory

type file struct {
	Name    string
	IsDir   bool
	Content string
}

const tplStr = `// Code generated by go generate; DO NOT EDIT.
package {{ .pkg }}

import (
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
)

type file struct {
	Name    string
	IsDir   bool
	Content string
}

var files = []file{
	{{ range $index,$elem := .files }}
	{"{{$elem.Name}}",{{$elem.IsDir}},"{{$elem.Content}}"},
	{{ end }}
}

func GenerateFiles(dir string) error {

	for _, v := range files {
		if !v.IsDir {
			continue
		}
		if err := os.MkdirAll(filepath.Join(dir, v.Name), 0755); err != nil {
			return err
		}
	}

	for _, v := range files {
		if v.IsDir {
			continue
		}
		bs, err := base64.StdEncoding.DecodeString(v.Content)
		if err != nil {
			return fmt.Errorf("filename:%s,err:%v", v.Name, err)
		}

		if err := ioutil.WriteFile(filepath.Join(dir, v.Name), bs, 0644); err != nil {
			return err
		}
	}
	return nil
}
`

func main() {

	flag.Parse()
	if *src == "" || *dst == "" || *pkg == "" {
		flag.PrintDefaults()
		return
	}

	srcInfo, err := os.Stat(*src)
	if err != nil {
		log.Fatalln(err)
	}

	if !srcInfo.IsDir() {
		log.Fatalln("src should be directory")
	}

	if _, err := os.Stat(*dst); err == nil {
		log.Fatalln("dst is exist")
	}

	files, err := readDir(*src)
	if err != nil {
		log.Fatalln("read Dir err", err)
	}

	data := map[string]interface{}{
		"pkg":   *pkg,
		"files": files,
	}

	tpl, err := template.New("gofile").Parse(tplStr)
	if err != nil {
		log.Fatalln(err)
	}

	buf := bytes.Buffer{}
	if err := tpl.Execute(&buf, data); err != nil {
		log.Fatalln(err)
	}

	if err := ioutil.WriteFile(*dst, buf.Bytes(), 0644); err != nil {
		log.Fatalln(err)
	}
}

func readDir(dir string) (files []file, err error) {

	files = append(files, file{Name: dir, IsDir: true})
	dentries, err := ioutil.ReadDir(dir)
	if err != nil {
		return nil, err
	}
	for _, v := range dentries {

		if v.IsDir() {
			subFiles, err := readDir(filepath.Join(dir, v.Name()))
			if err != nil {
				return nil, err
			}
			files = append(files, subFiles...)
		} else if v.Mode().IsRegular() {
			bs, err := ioutil.ReadFile(filepath.Join(dir, v.Name()))
			if err != nil {
				return nil, err
			}

			c := base64.StdEncoding.EncodeToString(bs)
			if _, err := base64.StdEncoding.DecodeString(c); err != nil {
				return nil, err
			}

			f := file{
				Name:    filepath.Join(dir, v.Name()),
				Content: base64.StdEncoding.EncodeToString(bs),
				IsDir:   false,
			}
			files = append(files, f)
		}
	}
	return
}
